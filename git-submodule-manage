#!/bin/bash

# Git extension for managing submodule URLs and branches
# Usage: git submodule-manage <command> [options]

set -e

SCRIPT_NAME="git submodule-manage"
DO_COMMIT=false
COMMIT_MSG=""
DRY_RUN=false
FORCE=false
DO_FIX=false
DO_ALL=false
DO_RECURSIVE=false

# Helper function to execute commands respecting DRY_RUN
run_cmd() {
    if [ "$DRY_RUN" = true ]; then
        echo "DRY-RUN: $*"
    else
        eval "$@"
    fi
}

check_dirty() {
    local subdir="$1"
    
    # If using force, skip check
    if [ "$FORCE" = true ]; then
        return 0
    fi
     
    if [ -d "$subdir" ]; then
        # Check for uncommitted changes in the submodule
        if ! (cd "$subdir" && git diff --quiet) || ! (cd "$subdir" && git diff --cached --quiet); then
             echo "Error: Submodule '$subdir' has uncommitted changes (dirty state)."
             echo "       Use --force to ignore (WARNING: may lose data) or commit/stash changes first."
             exit 1
        fi
    fi
}

commit_changes() {
    local default_msg="$1"
    shift
    local files=("$@")
    
    if [ "$DO_COMMIT" = true ]; then
        local msg="${COMMIT_MSG:-$default_msg}"
        echo "Committing changes..."
        
        # Construct the git command string for run_cmd
        local add_cmd="git add"
        for f in "${files[@]}"; do
            add_cmd="$add_cmd \"$f\""
        done
        
        run_cmd "$add_cmd"
        run_cmd "git commit -m \"$msg\""
        
        if [ "$DRY_RUN" = false ]; then
             echo "‚úÖ Changes committed: '$msg'"
        fi
    else
        if [ "$DRY_RUN" = false ]; then
            echo "Don't forget to commit the changes: git commit -m \"$default_msg\""
        fi
    fi
}

show_help() {
    cat << EOF
$SCRIPT_NAME - Manage submodule URLs and branches

USAGE:
    git submodule-manage <command> [args] [options]

COMMANDS:
    add <url> <path> [branch]             Add a new submodule, optionally tracking a branch
    remove <submodule-dir>                Cleanly remove a submodule
    update <submodule-dir>                Update submodule to latest remote commit
    reset <submodule-dir>                 Reset submodule to the commit recorded in parent
    diff <submodule-dir>                  Show commit summary between current and recorded state
    shallow <submodule-dir> <depth>       Convert submodule to shallow clone
    checkout <branch> <submodule-dir>     Switch submodule to specified branch
    remote <subcommand> ... <submodule>   Manage remotes (add, remove, rename, set-url, list)
    info [submodule-dir]                  Show submodule information
    inspect [submodule-dir]               Inspect submodules for issues (use --fix to repair)
    list                                  List all submodules

OPTIONS:
    --commit [msg]    Automatically add and commit changes to parent repo.
    --dry-run, -n     Show what would be done without making changes.
    --force, -f       Force operation (e.g. overwrite dirty submodules).
    --fix             Apply fixes during inspection.
    --all             Apply to all defined submodules (for info/inspect).
    --recursive       Apply recursively (for info/inspect).

EXAMPLES:
    git submodule-manage add https://github.com/foo/bar libs/bar main --commit
    git submodule-manage update libs/bar --dry-run
    git submodule-manage remove libs/bar --force

EOF
}

# Function to get the actual submodule name from .gitmodules
get_submodule_name() {
    local subdir="$1"
    
    # Try different approaches to find the submodule name
    local name=""
    
    # Method 1: Direct grep approach
    name=$(git config -f .gitmodules --get-regexp 'submodule\..*\.path' | grep " $subdir$" | head -1 | sed 's/^submodule\.\(.*\)\.path .*/\1/' || true)
    echo "DEBUG: Method 1 result: '$name'" >&2
    
    if [ -z "$name" ]; then
        # Method 2: Try without trailing slash
        local subdir_clean="${subdir%/}"
        name=$(git config -f .gitmodules --get-regexp 'submodule\..*\.path' | grep " $subdir_clean$" | head -1 | sed 's/^submodule\.\(.*\)\.path .*/\1/' || true)
        echo "DEBUG: Method 2 result: '$name'" >&2
    fi
    
    if [ -z "$name" ]; then
        # Method 3: Try with trailing slash
        local subdir_slash="${subdir}/"
        name=$(git config -f .gitmodules --get-regexp 'submodule\..*\.path' | grep " $subdir_slash$" | head -1 | sed 's/^submodule\.\(.*\)\.path .*/\1/' || true)
        echo "DEBUG: Method 3 result: '$name'" >&2
    fi
    
    if [ -z "$name" ]; then
        # Method 4: Manual parsing approach
        echo "DEBUG: Trying manual parsing" >&2
        while IFS= read -r line; do
            echo "DEBUG: Processing line: '$line'" >&2
            if [[ "$line" =~ submodule\.(.*)\.path[[:space:]]+(.*)$ ]]; then
                local found_name="${BASH_REMATCH[1]}"
                local found_path="${BASH_REMATCH[2]}"
                echo "DEBUG: Found name='$found_name', path='$found_path'" >&2
                if [ "$found_path" = "$subdir" ]; then
                    name="$found_name"
                    break
                fi
            fi
        done < <(git config -f .gitmodules --get-regexp 'submodule\..*\.path')
    fi
    
    if [ -n "$name" ]; then
        echo "$name"
    else
        echo "DEBUG: No match found, using path as fallback" >&2
        echo "$subdir"
    fi
}

validate_submodule() {
    local subdir="$1"
    if [ ! -d "$subdir" ]; then
        echo "Error: Directory '$subdir' does not exist"
        exit 1
    fi
    
    if [ ! -f "$subdir/.git" ] && [ ! -d "$subdir/.git" ]; then
        echo "Error: '$subdir' is not a git repository"
        exit 1
    fi
    
    # Check if it's actually a submodule
    if ! git submodule status "$subdir" > /dev/null 2>&1; then
        echo "Warning: '$subdir' exists but is not registered as a submodule"
    fi
}

add_submodule() {
    local url="$1"
    local subdir="$2"
    local branch="$3"
    
    echo "Adding submodule '$subdir' from '$url'..."
    
    if [ -d "$subdir" ]; then
         echo "Error: Directory '$subdir' already exists"
         exit 1
    fi
    
    git submodule add "$url" "$subdir"
    
    if [ -n "$branch" ]; then
        echo "Configuring to track branch '$branch'..."
        local submodule_name=$(get_submodule_name "$subdir")
        git config -f .gitmodules "submodule.$submodule_name.branch" "$branch"
    fi
    
    echo "‚úÖ Successfully added submodule '$subdir'"
    commit_changes "Add submodule $subdir" .gitmodules "$subdir"
}

remove_submodule() {
    local subdir="$1"
    
    echo "Removing submodule '$subdir'..."
    
    validate_submodule "$subdir"
    
    # Get the actual submodule name
    local submodule_name=$(get_submodule_name "$subdir")

    echo "De-initializing submodule..."
    git submodule deinit -f -- "$subdir"
    
    echo "Removing from .git/modules..."
    rm -rf ".git/modules/$submodule_name"
    
    echo "Removing from git..."
    git rm -f "$subdir"
    
    echo "‚úÖ Successfully removed submodule '$subdir'"
    commit_changes "Remove submodule $subdir" .gitmodules
}

update_submodule() {
    local subdir="$1"
    
    echo "Updating submodule '$subdir'..."
    
    validate_submodule "$subdir"
    
    # Update with remote
    git submodule update --remote --merge "$subdir"
    
    echo "‚úÖ Successfully updated submodule '$subdir'"
    commit_changes "Update submodule $subdir" "$subdir"
}

reset_submodule() {
    local subdir="$1"
    
    echo "Resetting submodule '$subdir'..."
    
    validate_submodule "$subdir"
    
    git submodule update --init --force --checkout "$subdir"
    
    echo "‚úÖ Successfully reset submodule '$subdir'"
    # Reset usually restores clean state to match parent commit, implying no change to parent.
    # However, if parent index was anticipating a change that we are reverting, we might want to commit?
    # No, typically 'reset' means "discard local changes", so matching parent.
    # But if we want to "reset submodule to its HEAD and commit that to parent" (like update), that's different.
    # The current 'reset' implementation does `git submodule update --init --force --checkout`.
    # This aligns the submodule worktree with the PARENT commit.
    # So there is nothing new to commit to parent.
}

diff_submodule() {
    local subdir="$1"
    
    validate_submodule "$subdir"
    
    echo "Diff for submodule '$subdir':"
    git diff --submodule=log "$subdir"
}

shallow_submodule() {
    local subdir="$1"
    local depth="$2"
    
    echo "Converting submodule '$subdir' to shallow clone (depth $depth)..."
    
    validate_submodule "$subdir"
    check_dirty "$subdir"
    
    run_cmd "git submodule deinit -f \"$subdir\""
    run_cmd "git submodule update --init --depth \"$depth\" \"$subdir\""
    
    if [ "$DRY_RUN" = false ]; then
        echo "‚úÖ Successfully converted '$subdir' to shallow clone"
    fi
}

checkout_branch() {
    local branch="$1"
    local subdir="$2"
    
    echo "Switching submodule '$subdir' to branch '$branch'"
    
    validate_submodule "$subdir"
    check_dirty "$subdir"
    
    cd "$subdir"
    
    # Fetch all branches
    echo "Fetching all branches..."
    run_cmd "git fetch --all"
    
    # Checkout the branch
    echo "Checking out branch '$branch'..."
    run_cmd "git checkout \"$branch\""
    
    # If it's a remote branch, set up tracking
    if [ "$DRY_RUN" = false ]; then
        if git show-ref --verify --quiet "refs/remotes/origin/$branch"; then
            run_cmd "git branch --set-upstream-to=\"origin/$branch\" \"$branch\" 2>/dev/null || true"
        fi
    else
        echo "DRY-RUN: git branch --set-upstream-to=\"origin/$branch\" \"$branch\" (if remote exists)"
    fi
    
    cd - > /dev/null
    
    # Get the actual submodule name
    local submodule_name=$(get_submodule_name "$subdir")
    
    # Update .gitmodules to track this branch
    echo "Updating .gitmodules to track branch '$branch'..."
    run_cmd "git config -f .gitmodules \"submodule.$submodule_name.branch\" \"$branch\""
    
    # Update the parent repository
    echo "Updating parent repository..."
    # git add "$subdir" .gitmodules <-- handled by commit_changes now
    
    if [ "$DRY_RUN" = false ]; then
        echo "‚úÖ Successfully switched '$subdir' to branch '$branch'"
    fi
    commit_changes "Update $subdir to branch $branch" "$subdir" .gitmodules
}

remote_add() {
    local name="$1"
    local url="$2"
    local subdir="$3"
    
    if [ -z "$subdir" ]; then echo "Error: Missing submodule directory"; exit 1; fi
    validate_submodule "$subdir"
    
    echo "Adding remote '$name' with URL '$url' to submodule '$subdir'"
    
    cd "$subdir"
    if git remote get-url "$name" > /dev/null 2>&1; then
        echo "Remote '$name' already exists."
    else
        run_cmd "git remote add \"$name\" \"$url\""
        run_cmd "git fetch \"$name\""
    fi
     cd - > /dev/null
}

remote_remove() {
    local name="$1"
    local subdir="$2"
    
    if [ -z "$subdir" ]; then echo "Error: Missing submodule directory"; exit 1; fi
    validate_submodule "$subdir"
    
    echo "Removing remote '$name' from submodule '$subdir'"
    
    cd "$subdir"
    run_cmd "git remote remove \"$name\""
    cd - > /dev/null
}

remote_rename() {
    local old="$1"
    local new="$2"
    local subdir="$3"
    
    if [ -z "$subdir" ]; then echo "Error: Missing submodule directory"; exit 1; fi
    validate_submodule "$subdir"
    
    echo "Renaming remote '$old' to '$new' in submodule '$subdir'"
    
    cd "$subdir"
    run_cmd "git remote rename \"$old\" \"$new\""
    cd - > /dev/null
}

remote_set_url() {
    local name="$1"
    local url="$2"
    local subdir="$3"
    
    if [ -z "$subdir" ]; then echo "Error: Missing submodule directory"; exit 1; fi
    validate_submodule "$subdir"
    check_dirty "$subdir"
    
    echo "Setting URL for remote '$name' in submodule '$subdir' to '$url'"
    
    if [ "$name" = "origin" ]; then
        # If origin, we also update .gitmodules
        local submodule_name=$(get_submodule_name "$subdir")
        echo "Updating .gitmodules..."
        run_cmd "git config -f .gitmodules \"submodule.$submodule_name.url\" \"$url\""
        
        echo "Updating submodule remote 'origin'..."
        cd "$subdir"
        run_cmd "git remote set-url origin \"$url\""
        cd - > /dev/null
        
        echo "Syncing submodule..."
        run_cmd "git submodule sync \"$subdir\""
        
        commit_changes "Update $subdir URL to $url" .gitmodules
    else
        # Just update the remote in the submodule
        cd "$subdir"
        run_cmd "git remote set-url \"$name\" \"$url\""
        cd - > /dev/null
    fi
}

remote_list() {
    local subdir="$1"
    local verbose="$2"
    
    if [ -z "$subdir" ]; then echo "Error: Missing submodule directory"; exit 1; fi
    validate_submodule "$subdir"
    
    echo "Remotes for submodule '$subdir':"
    cd "$subdir"
    if [ "$verbose" = "true" ]; then
        git remote -v
    else
        git remote
    fi
    cd - > /dev/null
}

cmd_remote() {
    local verbose=false
    if [ "$1" = "-v" ] || [ "$1" = "--verbose" ]; then
        verbose=true
        shift
    fi
    
    local subcommand="$1"
    shift
    
    case "$subcommand" in
        add)
             if [ $# -lt 3 ]; then
                 echo "Error: remote add requires name, url, and submodule directory"
                 exit 1
             fi
             remote_add "$1" "$2" "$3"
             ;;
        remove|rm)
             if [ $# -lt 2 ]; then
                 echo "Error: remote remove requires name and submodule directory"
                 exit 1
             fi
             remote_remove "$1" "$2"
             ;;
        rename)
             if [ $# -lt 3 ]; then
                 echo "Error: remote rename requires old-name, new-name, and submodule directory"
                 exit 1
             fi
             remote_rename "$1" "$2" "$3"
             ;;
        set-url)
             if [ $# -lt 3 ]; then
                 echo "Error: remote set-url requires name, url, and submodule directory"
                 exit 1
             fi
             remote_set_url "$1" "$2" "$3"
             ;;
        *)
             # Assume subcommand is actually the submodule directory (list command)
             if [ -n "$subcommand" ]; then
                 remote_list "$subcommand" "$verbose"
             else
                 echo "Error: Submodule directory required"
                 exit 1
             fi
             ;;
    esac
}

show_info() {
    local subdir="$1"
    
    # If no subdirectory provided, treat as 'all' if --all or --recursive is set
    # Or iterate over all. 
    # Logic in main case statement passes "" if no arg?
    # Actually main case logic checks arg count.
    
    if [ -n "$subdir" ]; then
        validate_submodule "$subdir"
        
        echo "=== Submodule Information: $subdir ==="
        echo
        
        # Get the actual submodule name
        local submodule_name=$(get_submodule_name "$subdir")
        
        # Show .gitmodules info
        echo "üìÅ .gitmodules configuration:"
        echo "   Submodule name: $submodule_name"
        echo "   URL: $(git config -f .gitmodules submodule.$submodule_name.url 2>/dev/null || echo "Not set")"
        echo "   Branch: $(git config -f .gitmodules submodule.$submodule_name.branch 2>/dev/null || echo "Not set")"
        echo
        
        # Show current status
        echo "üìä Current status:"
        git submodule status "$subdir"
        echo
        
        # Show submodule's git info
        echo "üîç Git information:"
        cd "$subdir"
        echo "   Current branch: $(git branch --show-current 2>/dev/null || echo "Detached HEAD")"
        echo "   Current commit: $(git rev-parse --short HEAD)"
        echo "   Current commit message: $(git log -1 --pretty=format:'%s')"
        echo
        
        echo "üåê Remotes:"
        git remote -v
        
        cd - > /dev/null
    else 
        # Iterate based on context
        local recursive_flag=""
        if [ "$DO_RECURSIVE" = true ]; then
            recursive_flag="--recursive"
        fi
        
        if [ "$DO_ALL" = true ] || [ "$DO_RECURSIVE" = true ]; then
             echo "=== All Submodules Information ==="
             if [ -n "$recursive_flag" ]; then
                 git submodule status $recursive_flag | awk '{print $2}' | while read -r path; do
                     echo "----------------------------------------"
                     show_info "$path"
                 done
             else
                 git config -f .gitmodules --get-regexp path | awk '{print $2}' | while read -r path; do
                     echo "----------------------------------------"
                     show_info "$path"
                 done
             fi
        else
             echo "Error: Directory required or use --all / --recursive"
             exit 1
        fi
    fi
}

list_submodules() {
    echo "=== All Submodules ==="
    echo
    
    if [ ! -f .gitmodules ]; then
        echo "No submodules found (no .gitmodules file)"
        return
    fi
    
    git submodule foreach --quiet 'echo "üìÅ $name ($sha1)"'
    echo
    
    echo "=== Submodule Status ==="
    git submodule status
}

inspect_single() {
    local subdir="$1"
    echo "Inspecting '$subdir'..."
    
    if [ ! -d "$subdir" ]; then
        echo "‚ùå Directory missing."
        if [ "$DO_FIX" = true ]; then
            echo "üîß Fixing: Expected submodule directory missing..."
            run_cmd "git submodule update --init \"$subdir\""
            return
        else
            echo "   Suggestion: git submodule update --init \"$subdir\" (Initializes and clones the submodule)"
            return
        fi
    fi
    
    local name=$(get_submodule_name "$subdir")
    local issues=0
    
    # 1. Check URL Mismatch
    local url_mod=$(git config -f .gitmodules submodule.$name.url || echo "")
    local url_local=$(cd "$subdir" && git remote get-url origin 2>/dev/null || echo "")
    
    # Sometimes urls differ by .git suffix or trailing slash, simplistic check
    if [ "$url_mod" != "$url_local" ]; then
        echo "‚ö†Ô∏è  URL mismatch:"
        echo "   .gitmodules:  $url_mod"
        echo "   Local origin: $url_local"
        if [ "$DO_FIX" = true ]; then
             echo "üîß Fixing: Syncing submodule URL..."
             run_cmd "git submodule sync \"$subdir\""
             # Refresh local url
             url_local=$(cd "$subdir" && git remote get-url origin 2>/dev/null || echo "")
        else
             echo "   Suggestion: git submodule sync \"$subdir\" (Syncs local remote URL with .gitmodules)"
             issues=$((issues + 1))
        fi
    fi
    
    # 2. Check Branch Mismatch
    local branch_mod=$(git config -f .gitmodules submodule.$name.branch || echo "")
    local branch_local=$(cd "$subdir" && git branch --show-current 2>/dev/null || echo "")
    
    if [ -n "$branch_mod" ]; then
        if [ "$branch_local" != "$branch_mod" ]; then
             echo "‚ö†Ô∏è  Branch mismatch:"
             echo "   .gitmodules configured branch: '$branch_mod'"
             echo "   Current checked out branch:    '${branch_local:-Detached HEAD}'"
             if [ "$DO_FIX" = true ]; then
                 echo "üîß Fixing: Checking out branch '$branch_mod'..."
                 # Run in subshell to avoid changing directory for main script
                 (cd "$subdir" && run_cmd "git checkout \"$branch_mod\"")
             else
                 echo "   Suggestion: git submodule-manage checkout \"$branch_mod\" \"$subdir\" (Switches to configured branch)"
                 issues=$((issues + 1))
             fi
        fi
    fi
    
    # 3. Check Commit Status
    local status_line=$(git submodule status "$subdir")
    local status_char="${status_line:0:1}"
    
    if [ "$status_char" = "+" ]; then
        echo "‚ö†Ô∏è  Commit mismatch (Parent index vs Submodule HEAD):"
        echo "   The submodule is on a different commit than recorded in the parent."
        if [ "$DO_FIX" = true ]; then
             # Ambiguous what "fix" means here. Usually "update submodule to match parent".
             echo "üîß Fixing: Updating submodule to match parent commit..."
             run_cmd "git submodule update \"$subdir\""
        else
             echo "   Suggestion 1 (Update submodule): git submodule-manage update \"$subdir\" (Discards local changes, resets to parent's commit)"
             echo "   Suggestion 2 (Update parent):    git add \"$subdir\" (Records current submodule commit in parent)"
             issues=$((issues + 1))
        fi
    elif [ "$status_char" = "-" ]; then
        echo "‚ùå Submodule not initialized"
        if [ "$DO_FIX" = true ]; then
             echo "üîß Fixing: Initializing submodule..."
             run_cmd "git submodule update --init \"$subdir\""
        else
             echo "   Suggestion: git submodule update --init \"$subdir\" (Initializes the submodule)"
             issues=$((issues + 1))
        fi
    elif [ "$status_char" = "U" ]; then
        echo "‚ùå Merge conflicts in submodule reference"
        echo "   Manual intervention required for merge conflicts."
        issues=$((issues + 1))
    fi
    
    # 4. Check Dirty State
    if ! (cd "$subdir" && git diff --quiet) || ! (cd "$subdir" && git diff --cached --quiet); then
        echo "‚ö†Ô∏è  Dirty worktree (Uncommitted changes):"
        echo "   The submodule has local modifications."
        echo "   Suggestion: cd \"$subdir\" && git status (Inspect local changes)"
        issues=$((issues + 1))
    fi
    
    if [ $issues -eq 0 ]; then
        echo "‚úÖ Everything looks good."
    elif [ "$DO_FIX" = true ]; then
        echo "‚úÖ Fixes applied where possible."
    else
        echo "Found $issues issue(s)."
    fi
}

show_inspect() {
    local subdir="$1"
    
    if [ -n "$subdir" ]; then
        inspect_single "$subdir"
    else
        local recursive_flag=""
        if [ "$DO_RECURSIVE" = true ]; then
            recursive_flag="--recursive"
        fi
        
        echo "=== Inspecting Submodules ==="
        
        if [ "$DO_ALL" = true ] || [ "$DO_RECURSIVE" = true ]; then
             if [ -n "$recursive_flag" ]; then
                 # Use submodule status for recursive traversal
                 git submodule status $recursive_flag | awk '{print $2}' | while read -r path; do
                     echo "----------------------------------------"
                     inspect_single "$path"
                 done
             else
                 # Use .gitmodules for all top-level defined submodules
                 if [ ! -f .gitmodules ]; then
                     echo "No .gitmodules found."
                     return
                 fi
                 git config -f .gitmodules --get-regexp path | awk '{print $2}' | while read -r path; do
                     echo "----------------------------------------"
                     inspect_single "$path"
                 done
             fi
        else
            # Default behavior: Inspect configured submodules (non-recursive)
            if [ ! -f .gitmodules ]; then
                 echo "No .gitmodules found."
                 return
            fi
            git config -f .gitmodules --get-regexp path | awk '{print $2}' | while read -r path; do
                echo "----------------------------------------"
                inspect_single "$path"
            done
        fi
        echo "----------------------------------------"
    fi
}


# Helper to parse common options and set flags
parse_common_options() {
    # We iterate through all arguments to check for flags
    # We reconstruct the arguments array to remove the flags for the main function
    local new_args=()
    while [ $# -gt 0 ]; do
        case "$1" in
            --commit)
                DO_COMMIT=true
                if [ -n "$2" ] && [[ "$2" != --* ]]; then
                    COMMIT_MSG="$2"
                    shift
                fi
                shift
                ;;
            --dry-run|-n)
                DRY_RUN=true
                shift
                ;;
            --force|-f)
                FORCE=true
                shift
                ;;
            --fix)
                DO_FIX=true
                shift
                ;;
            --all)
                DO_ALL=true
                shift
                ;;
            --recursive)
                DO_RECURSIVE=true
                shift
                ;;
            *)
                # Keep other arguments
                ARGS+=("$1")
                shift
                ;;
        esac
    done
}

# Main script logic
ARGS=()
# Extract command first
COMMAND="$1"
shift 1
parse_common_options "$@"
set -- "${ARGS[@]}"

case "$COMMAND" in
    "add")
        if [ $# -lt 2 ]; then
            echo "Error: add requires URL and submodule directory"
            echo "Usage: git submodule-manage add <url> <submodule-dir> [branch] [options]"
            exit 1
        fi
        add_submodule "$1" "$2" "$3"
        ;;
    "remove")
        if [ $# -lt 1 ]; then
            echo "Error: remove requires submodule directory"
            echo "Usage: git submodule-manage remove <submodule-dir> [options]"
            exit 1
        fi
        remove_submodule "$1"
        ;;
    "update")
        if [ $# -lt 1 ]; then
            echo "Error: update requires submodule directory"
            echo "Usage: git submodule-manage update <submodule-dir> [options]"
            exit 1
        fi
        update_submodule "$1"
        ;;
    "reset")
        if [ $# -lt 1 ]; then
            echo "Error: reset requires submodule directory"
            echo "Usage: git submodule-manage reset <submodule-dir> [options]"
            exit 1
        fi
        reset_submodule "$1"
        ;;
    "diff")
        if [ $# -lt 1 ]; then
            echo "Error: diff requires submodule directory"
            echo "Usage: git submodule-manage diff <submodule-dir>"
            exit 1
        fi
        diff_submodule "$1"
        ;;
    "shallow")
        if [ $# -lt 2 ]; then
            echo "Error: shallow requires submodule directory and depth"
            echo "Usage: git submodule-manage shallow <submodule-dir> <depth> [options]"
            exit 1
        fi
        shallow_submodule "$1" "$2"
        ;;
    "checkout")
        if [ $# -lt 2 ]; then
            echo "Error: checkout requires branch and submodule directory"
            echo "Usage: git submodule-manage checkout <branch> <submodule-dir> [options]"
            exit 1
        fi
        checkout_branch "$1" "$2"
        ;;
    "remote")
        cmd_remote "$@"
        ;;
    "info")
        # info can take 0 or 1 args (submodule dir)
        show_info "$1"
        ;;
    "inspect")
        # inspect can take 0 or 1 args (submodule dir)
        show_inspect "$1"
        ;;
    "list")
        list_submodules
        ;;
    "-h"|"--help"|"help")
        show_help
        ;;
    *)
        echo "Error: Unknown command '$COMMAND'"
        echo
        show_help
        exit 1
        ;;
esac
