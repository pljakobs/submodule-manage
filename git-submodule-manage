#!/bin/bash

# Git extension for managing submodule URLs and branches
# Usage: git submodule-manage <command> [options]

set -e

SCRIPT_NAME="git submodule-manage"
DO_COMMIT=false
COMMIT_MSG=""
DRY_RUN=false
FORCE=false

# Helper function to execute commands respecting DRY_RUN
run_cmd() {
    if [ "$DRY_RUN" = true ]; then
        echo "DRY-RUN: $*"
    else
        eval "$@"
    fi
}

check_dirty() {
    local subdir="$1"
    
    # If using force, skip check
    if [ "$FORCE" = true ]; then
        return 0
    fi
     
    if [ -d "$subdir" ]; then
        # Check for uncommitted changes in the submodule
        if ! (cd "$subdir" && git diff --quiet) || ! (cd "$subdir" && git diff --cached --quiet); then
             echo "Error: Submodule '$subdir' has uncommitted changes (dirty state)."
             echo "       Use --force to ignore (WARNING: may lose data) or commit/stash changes first."
             exit 1
        fi
    fi
}

commit_changes() {
    local default_msg="$1"
    shift
    local files=("$@")
    
    if [ "$DO_COMMIT" = true ]; then
        local msg="${COMMIT_MSG:-$default_msg}"
        echo "Committing changes..."
        
        # Construct the git command string for run_cmd
        local add_cmd="git add"
        for f in "${files[@]}"; do
            add_cmd="$add_cmd \"$f\""
        done
        
        run_cmd "$add_cmd"
        run_cmd "git commit -m \"$msg\""
        
        if [ "$DRY_RUN" = false ]; then
             echo "‚úÖ Changes committed: '$msg'"
        fi
    else
        if [ "$DRY_RUN" = false ]; then
            echo "Don't forget to commit the changes: git commit -m \"$default_msg\""
        fi
    fi
}

show_help() {
    cat << EOF
$SCRIPT_NAME - Manage submodule URLs and branches

USAGE:
    git submodule-manage <command> [args] [options]

COMMANDS:
    add <url> <path> [branch]             Add a new submodule, optionally tracking a branch
    remove <submodule-dir>                Cleanly remove a submodule
    update <submodule-dir>                Update submodule to latest remote commit
    reset <submodule-dir>                 Reset submodule to the commit recorded in parent
    diff <submodule-dir>                  Show commit summary between current and recorded state
    shallow <submodule-dir> <depth>       Convert submodule to shallow clone
    checkout <branch> <submodule-dir>     Switch submodule to specified branch
    set-url <url> <submodule-dir>         Change the origin URL of submodule
    add-remote <name> <url> <submodule>   Add additional remote to submodule
    info <submodule-dir>                  Show submodule information
    list                                  List all submodules

OPTIONS:
    --commit [msg]    Automatically add and commit changes to parent repo.
    --dry-run, -n     Show what would be done without making changes.
    --force, -f       Force operation (e.g. overwrite dirty submodules).

EXAMPLES:
    git submodule-manage add https://github.com/foo/bar libs/bar main --commit
    git submodule-manage update libs/bar --dry-run
    git submodule-manage remove libs/bar --force

EOF
}

# Function to get the actual submodule name from .gitmodules
get_submodule_name() {
    local subdir="$1"
    
    # Try different approaches to find the submodule name
    local name=""
    
    # Method 1: Direct grep approach
    name=$(git config -f .gitmodules --get-regexp 'submodule\..*\.path' | grep " $subdir$" | head -1 | sed 's/^submodule\.\(.*\)\.path .*/\1/' || true)
    echo "DEBUG: Method 1 result: '$name'" >&2
    
    if [ -z "$name" ]; then
        # Method 2: Try without trailing slash
        local subdir_clean="${subdir%/}"
        name=$(git config -f .gitmodules --get-regexp 'submodule\..*\.path' | grep " $subdir_clean$" | head -1 | sed 's/^submodule\.\(.*\)\.path .*/\1/' || true)
        echo "DEBUG: Method 2 result: '$name'" >&2
    fi
    
    if [ -z "$name" ]; then
        # Method 3: Try with trailing slash
        local subdir_slash="${subdir}/"
        name=$(git config -f .gitmodules --get-regexp 'submodule\..*\.path' | grep " $subdir_slash$" | head -1 | sed 's/^submodule\.\(.*\)\.path .*/\1/' || true)
        echo "DEBUG: Method 3 result: '$name'" >&2
    fi
    
    if [ -z "$name" ]; then
        # Method 4: Manual parsing approach
        echo "DEBUG: Trying manual parsing" >&2
        while IFS= read -r line; do
            echo "DEBUG: Processing line: '$line'" >&2
            if [[ "$line" =~ submodule\.(.*)\.path[[:space:]]+(.*)$ ]]; then
                local found_name="${BASH_REMATCH[1]}"
                local found_path="${BASH_REMATCH[2]}"
                echo "DEBUG: Found name='$found_name', path='$found_path'" >&2
                if [ "$found_path" = "$subdir" ]; then
                    name="$found_name"
                    break
                fi
            fi
        done < <(git config -f .gitmodules --get-regexp 'submodule\..*\.path')
    fi
    
    if [ -n "$name" ]; then
        echo "$name"
    else
        echo "DEBUG: No match found, using path as fallback" >&2
        echo "$subdir"
    fi
}

validate_submodule() {
    local subdir="$1"
    if [ ! -d "$subdir" ]; then
        echo "Error: Directory '$subdir' does not exist"
        exit 1
    fi
    
    if [ ! -f "$subdir/.git" ] && [ ! -d "$subdir/.git" ]; then
        echo "Error: '$subdir' is not a git repository"
        exit 1
    fi
    
    # Check if it's actually a submodule
    if ! git submodule status "$subdir" > /dev/null 2>&1; then
        echo "Warning: '$subdir' exists but is not registered as a submodule"
    fi
}

add_submodule() {
    local url="$1"
    local subdir="$2"
    local branch="$3"
    
    echo "Adding submodule '$subdir' from '$url'..."
    
    if [ -d "$subdir" ]; then
         echo "Error: Directory '$subdir' already exists"
         exit 1
    fi
    
    git submodule add "$url" "$subdir"
    
    if [ -n "$branch" ]; then
        echo "Configuring to track branch '$branch'..."
        local submodule_name=$(get_submodule_name "$subdir")
        git config -f .gitmodules "submodule.$submodule_name.branch" "$branch"
    fi
    
    echo "‚úÖ Successfully added submodule '$subdir'"
    commit_changes "Add submodule $subdir" .gitmodules "$subdir"
}

remove_submodule() {
    local subdir="$1"
    
    echo "Removing submodule '$subdir'..."
    
    validate_submodule "$subdir"
    
    # Get the actual submodule name
    local submodule_name=$(get_submodule_name "$subdir")

    echo "De-initializing submodule..."
    git submodule deinit -f -- "$subdir"
    
    echo "Removing from .git/modules..."
    rm -rf ".git/modules/$submodule_name"
    
    echo "Removing from git..."
    git rm -f "$subdir"
    
    echo "‚úÖ Successfully removed submodule '$subdir'"
    commit_changes "Remove submodule $subdir" .gitmodules
}

update_submodule() {
    local subdir="$1"
    
    echo "Updating submodule '$subdir'..."
    
    validate_submodule "$subdir"
    
    # Update with remote
    git submodule update --remote --merge "$subdir"
    
    echo "‚úÖ Successfully updated submodule '$subdir'"
    commit_changes "Update submodule $subdir" "$subdir"
}

reset_submodule() {
    local subdir="$1"
    
    echo "Resetting submodule '$subdir'..."
    
    validate_submodule "$subdir"
    
    git submodule update --init --force --checkout "$subdir"
    
    echo "‚úÖ Successfully reset submodule '$subdir'"
    # Reset usually restores clean state to match parent commit, implying no change to parent.
    # However, if parent index was anticipating a change that we are reverting, we might want to commit?
    # No, typically 'reset' means "discard local changes", so matching parent.
    # But if we want to "reset submodule to its HEAD and commit that to parent" (like update), that's different.
    # The current 'reset' implementation does `git submodule update --init --force --checkout`.
    # This aligns the submodule worktree with the PARENT commit.
    # So there is nothing new to commit to parent.
}

diff_submodule() {
    local subdir="$1"
    
    validate_submodule "$subdir"
    
    echo "Diff for submodule '$subdir':"
    git diff --submodule=log "$subdir"
}

shallow_submodule() {
    local subdir="$1"
    local depth="$2"
    
    echo "Converting submodule '$subdir' to shallow clone (depth $depth)..."
    
    validate_submodule "$subdir"
    check_dirty "$subdir"
    
    run_cmd "git submodule deinit -f \"$subdir\""
    run_cmd "git submodule update --init --depth \"$depth\" \"$subdir\""
    
    if [ "$DRY_RUN" = false ]; then
        echo "‚úÖ Successfully converted '$subdir' to shallow clone"
    fi
}

checkout_branch() {
    local branch="$1"
    local subdir="$2"
    
    echo "Switching submodule '$subdir' to branch '$branch'"
    
    validate_submodule "$subdir"
    check_dirty "$subdir"
    
    cd "$subdir"
    
    # Fetch all branches
    echo "Fetching all branches..."
    run_cmd "git fetch --all"
    
    # Checkout the branch
    echo "Checking out branch '$branch'..."
    run_cmd "git checkout \"$branch\""
    
    # If it's a remote branch, set up tracking
    if [ "$DRY_RUN" = false ]; then
        if git show-ref --verify --quiet "refs/remotes/origin/$branch"; then
            run_cmd "git branch --set-upstream-to=\"origin/$branch\" \"$branch\" 2>/dev/null || true"
        fi
    else
        echo "DRY-RUN: git branch --set-upstream-to=\"origin/$branch\" \"$branch\" (if remote exists)"
    fi
    
    cd - > /dev/null
    
    # Get the actual submodule name
    local submodule_name=$(get_submodule_name "$subdir")
    
    # Update .gitmodules to track this branch
    echo "Updating .gitmodules to track branch '$branch'..."
    run_cmd "git config -f .gitmodules \"submodule.$submodule_name.branch\" \"$branch\""
    
    # Update the parent repository
    echo "Updating parent repository..."
    # git add "$subdir" .gitmodules <-- handled by commit_changes now
    
    if [ "$DRY_RUN" = false ]; then
        echo "‚úÖ Successfully switched '$subdir' to branch '$branch'"
    fi
    commit_changes "Update $subdir to branch $branch" "$subdir" .gitmodules
}

set_url() {
    local url="$1"
    local subdir="$2"
    
    echo "Setting URL for submodule '$subdir' to '$url'"
    
    validate_submodule "$subdir"
    check_dirty "$subdir"
    
    # Get the actual submodule name
    local submodule_name=$(get_submodule_name "$subdir")
    
    # Update .gitmodules
    echo "Updating .gitmodules..."
    run_cmd "git config -f .gitmodules \"submodule.$submodule_name.url\" \"$url\""
    
    # Update submodule's origin
    echo "Updating submodule's remote origin..."
    cd "$subdir"
    run_cmd "git remote set-url origin \"$url\""
    cd - > /dev/null
    
    # Sync the changes
    echo "Syncing submodule..."
    run_cmd "git submodule sync \"$subdir\""
    
    if [ "$DRY_RUN" = false ]; then
         echo "‚úÖ Successfully updated URL for '$subdir'"
    fi
    commit_changes "Update $subdir URL to $url" .gitmodules
}

add_remote() {
    local name="$1"
    local url="$2"
    local subdir="$3"
    
    echo "Adding remote '$name' with URL '$url' to submodule '$subdir'"
    
    validate_submodule "$subdir"
    
    cd "$subdir"
    
    # Check if remote already exists
    if git remote get-url "$name" > /dev/null 2>&1; then
        echo "Remote '$name' already exists. Updating URL..."
        run_cmd "git remote set-url \"$name\" \"$url\""
    else
        echo "Adding new remote '$name'..."
        run_cmd "git remote add \"$name\" \"$url\""
    fi
    
    # Fetch from new remote
    echo "Fetching from remote '$name'..."
    run_cmd "git fetch \"$name\""
    
    cd - > /dev/null
    
    if [ "$DRY_RUN" = false ]; then
         echo "‚úÖ Successfully added/updated remote '$name' for '$subdir'"
    fi
}

show_info() {
    local subdir="$1"
    
    validate_submodule "$subdir"
    
    echo "=== Submodule Information: $subdir ==="
    echo
    
    # Get the actual submodule name
    local submodule_name=$(get_submodule_name "$subdir")
    
    # Show .gitmodules info
    echo "üìÅ .gitmodules configuration:"
    echo "   Submodule name: $submodule_name"
    echo "   URL: $(git config -f .gitmodules submodule.$submodule_name.url 2>/dev/null || echo "Not set")"
    echo "   Branch: $(git config -f .gitmodules submodule.$submodule_name.branch 2>/dev/null || echo "Not set")"
    echo
    
    # Show current status
    echo "üìä Current status:"
    git submodule status "$subdir"
    echo
    
    # Show submodule's git info
    echo "üîç Git information:"
    cd "$subdir"
    echo "   Current branch: $(git branch --show-current 2>/dev/null || echo "Detached HEAD")"
    echo "   Current commit: $(git rev-parse --short HEAD)"
    echo "   Current commit message: $(git log -1 --pretty=format:'%s')"
    echo
    
    echo "üåê Remotes:"
    git remote -v
    
    cd - > /dev/null
}

list_submodules() {
    echo "=== All Submodules ==="
    echo
    
    if [ ! -f .gitmodules ]; then
        echo "No submodules found (no .gitmodules file)"
        return
    fi
    
    git submodule foreach --quiet 'echo "üìÅ $name ($sha1)"'
    echo
    
    echo "=== Submodule Status ==="
    git submodule status
}

# Helper to parse common options and set flags
parse_common_options() {
    # We iterate through all arguments to check for flags
    # We reconstruct the arguments array to remove the flags for the main function
    local new_args=()
    while [ $# -gt 0 ]; do
        case "$1" in
            --commit)
                DO_COMMIT=true
                if [ -n "$2" ] && [[ "$2" != --* ]]; then
                    COMMIT_MSG="$2"
                    shift
                fi
                shift
                ;;
            --dry-run|-n)
                DRY_RUN=true
                shift
                ;;
            --force|-f)
                FORCE=true
                shift
                ;;
            *)
                # Keep other arguments
                ARGS+=("$1")
                shift
                ;;
        esac
    done
}

# Main script logic
ARGS=()
# Extract command first
COMMAND="$1"
shift 1
parse_common_options "$@"
set -- "${ARGS[@]}"

case "$COMMAND" in
    "add")
        if [ $# -lt 2 ]; then
            echo "Error: add requires URL and submodule directory"
            echo "Usage: git submodule-manage add <url> <submodule-dir> [branch] [options]"
            exit 1
        fi
        add_submodule "$1" "$2" "$3"
        ;;
    "remove")
        if [ $# -lt 1 ]; then
            echo "Error: remove requires submodule directory"
            echo "Usage: git submodule-manage remove <submodule-dir> [options]"
            exit 1
        fi
        remove_submodule "$1"
        ;;
    "update")
        if [ $# -lt 1 ]; then
            echo "Error: update requires submodule directory"
            echo "Usage: git submodule-manage update <submodule-dir> [options]"
            exit 1
        fi
        update_submodule "$1"
        ;;
    "reset")
        if [ $# -lt 1 ]; then
            echo "Error: reset requires submodule directory"
            echo "Usage: git submodule-manage reset <submodule-dir> [options]"
            exit 1
        fi
        reset_submodule "$1"
        ;;
    "diff")
        if [ $# -lt 1 ]; then
            echo "Error: diff requires submodule directory"
            echo "Usage: git submodule-manage diff <submodule-dir>"
            exit 1
        fi
        diff_submodule "$1"
        ;;
    "shallow")
        if [ $# -lt 2 ]; then
            echo "Error: shallow requires submodule directory and depth"
            echo "Usage: git submodule-manage shallow <submodule-dir> <depth> [options]"
            exit 1
        fi
        shallow_submodule "$1" "$2"
        ;;
    "checkout")
        if [ $# -lt 2 ]; then
            echo "Error: checkout requires branch and submodule directory"
            echo "Usage: git submodule-manage checkout <branch> <submodule-dir> [options]"
            exit 1
        fi
        checkout_branch "$1" "$2"
        ;;
    "set-url")
        if [ $# -lt 2 ]; then
            echo "Error: set-url requires URL and submodule directory"
            echo "Usage: git submodule-manage set-url <url> <submodule-dir> [options]"
            exit 1
        fi
        set_url "$1" "$2"
        ;;
    "add-remote")
        if [ $# -lt 3 ]; then
            echo "Error: add-remote requires name, URL, and submodule directory"
            echo "Usage: git submodule-manage add-remote <name> <url> <submodule-dir> [options]"
            exit 1
        fi
        add_remote "$1" "$2" "$3"
        ;;
    "info")
        if [ $# -lt 1 ]; then
            echo "Error: info requires submodule directory"
            echo "Usage: git submodule-manage info <submodule-dir>"
            exit 1
        fi
        show_info "$1"
        ;;
    "list")
        list_submodules
        ;;
    "-h"|"--help"|"help")
        show_help
        ;;
    *)
        echo "Error: Unknown command '$COMMAND'"
        echo
        show_help
        exit 1
        ;;
esac
